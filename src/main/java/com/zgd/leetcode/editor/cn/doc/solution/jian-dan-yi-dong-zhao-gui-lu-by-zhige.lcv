因为题目描述中写到要求时间复杂度为O(n)，所以想到能否遍历输入数字的每一位来得到答案。按照这个思路进行思考，发现了每一位可能为1的个数是有一定的规律，**按照规律遍历所有数位上的数，将每一位上能取到的1的个数相加，即可得到最终结果。**

**所发现的规律如下：**
每一位上的数字有三种可能：大于1，等于1，小于1。

**1.当给出的n中某一位上的数字大于1时**
如果倒数第x位上的数字大于1，则该位置上的数为1的情况有(preNum+1)·(10^(x-1))种，比如n=32514,正数第2位，也就是倒数第4位的数字为2，大于1，此时该位置为1的情况有4·1000种，即(01000~01999) + (11000~11999) + (21000~21999) + (31000~31999)。再如正数第1位，也就是倒数第5位的数字为3，大于1，此时该位置上为1的情况有(0+1)·10000种,即10000~19999。
总结该规律，即当给出的n中某一位(倒数第x位)上的数字为大于1时，该位置上为1的情况有(preNum+1)·(10^(x-1))种，其中preNum为该位数字前面的所有数字组成的数字。根据此规律，倒数第三位上的数字为5，大于1，其前面的数字为32，因此该位置上为1的可能情况有(32+1)·100种。
**2.当给出的n中某一位上的数字等于1时**
如果倒数第x位上的数字等于1，则该位置上的数为1的情况有preNum·(10^(x-1))+postNum+1种，其中postNum为该位数字之后的所有数字所组成的数字。比如n=31567，正数第2位，也就是倒数第4位的数字为1，此时该位置为1的情况有3·1000+568种，即(01000~01999) + (11000~11999) + (21000~21999) + (31000~31567)。再比如14，第一位上的数字等于1，该位上数字为1的可能的情况有5种，即10，11，12，13，14。
**3.当给出的n中某一位上的数字小于1时**
如果倒数第x位上的数字小于1，则该位置上的数为1的情况有preNum·(10^(x-1))种。比如n=30567，正数第2位，也就是倒数第4位的数字为0，此时该位置为1的情况有3·1000种，即(01000~01999) + (11000~11999) + (21000~21999)。

找到上述规律，遍历数字n中每一位数字，将每个数位上的可以为1的个数相加，即可得到最终结果。Java的实现代码如下：

* 

```
class Solution {
    public int countDigitOne(int n) {
        //处理输入数字n，将其每一位按照从高位到低位放入数组arr
        int x = n;
        int m;
        Stack<Integer> stack = new Stack<>();
        while(true){
            m = x%10;
            x = x/10;
            stack.add(m);
            if(x == 0){
                break;
            }
        }
        int l = stack.size();
        int[] arr = new int[l];
        for(int i = 0; i < l; i++){
            arr[i] = stack.pop();
        }
        //初始化参数
        int sumOfOne = 0;   //记录1的个数
        int preNum = 0;     //记录当前处理数位的之前的数字
        int postNum = 0;    //记录当前处理数位之后的数字
        //初始化postNum
        for(int i = 1; i < l; i++){
            postNum = postNum * 10 + arr[i];
        }
        //遍历所有数位
        for(int i = 0; i < l; i++){
            if(arr[i] > 1){//当前数位上的数字大于1的情况
                sumOfOne = sumOfOne + (preNum + 1) * (int)Math.pow(10,l-1-i);
            }else if(arr[i] == 1){//当前数位上的数字等于1的情况
                sumOfOne = sumOfOne + preNum *  (int)Math.pow(10,l-1-i) + postNum + 1;
            }else{//当前数位上的数字小于1的情况
                sumOfOne = sumOfOne + preNum *  (int)Math.pow(10,l-1-i);
            }
            if(i < l-1){//更新preNum和postNum，用于下一位数字的遍历
                preNum = preNum * 10 + arr[i];
                postNum = postNum - arr[i+1] *  (int)Math.pow(10,l-2-i);
            }
        }
        return sumOfOne;
    }
}
```

该方法的时间复杂度为O(n),运行结果：
![微信图片_20200427215319.png](https://pic.leetcode-cn.com/05a8b5e7b085d0cfd464923a2ef23862a0c3d603e8fcaa37a5700b29614d9064-%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20200427215319.png)

**该方法可以拓展到寻找1~n中出现的所有数字x的次数。只需将规律中与1比较的条件变为与x进行比较。**
