### è§£é¢˜æ€è·¯

æ€»ä½“æ¥è®²ï¼Œè¿™æ˜¯ä¸€é“éå¸¸å€¼å¾—å­¦ä¹ çš„hardé¢˜ï¼ä¸ºä»€ä¹ˆè¯´å®ƒæ˜¯ä¸€é“éå¸¸å€¼å¾—å­¦ä¹ çš„hardé¢˜å‘¢ï¼Ÿå› ä¸ºå®ƒæœ‰ä»¥ä¸‹å‡ å¤§çŸ¥è¯†ç‚¹ï¼š
1. å¦‚ä½•å°†ä¸€ä¸ªé—®é¢˜æŠ½è±¡æˆå›¾çš„é—®é¢˜ï¼Ÿ
2. å¦‚ä½•å»ºå›¾ï¼Ÿ
3. å¦‚ä½•è§£å†³æ— å‘å›¾é‡Œçš„æœ€çŸ­è·¯å¾„é—®é¢˜

ä¸‹é¢ï¼Œæˆ‘ä»¬å°±æ¥ä¸€ä¸ªä¸€ä¸ªè§£å†³è¿™ä¸‰é—®é¢˜ã€‚

### 1. å¦‚ä½•å°†ä¸€ä¸ªé—®é¢˜æŠ½è±¡æˆå›¾çš„é—®é¢˜ï¼Ÿ

é¦–å…ˆï¼Œå¦‚ä½•å°†ä¸€ä¸ªé—®é¢˜æŠ½è±¡æˆå›¾çš„é—®é¢˜ã€‚æˆ‘ä»¬çŸ¥é“å›¾æ˜¯ç”±è‹¥å¹²ç‚¹å’Œè‹¥å¹²ç‚¹ä¹‹é—´çš„è¾¹ç»„æˆçš„(ps.å¥½åƒè¿™ä¸ªè¯´äº†ä¹Ÿæ²¡å•¥ç”¨å’³å’³)ã€‚åœ¨è§£å†³è¿™ä¸ªé—®é¢˜å‰ï¼Œæˆ‘ä»¬å¯ä»¥ä»**å…ƒç´ é—´çš„å…³ç³»**è¿™ä¸ªè§’åº¦æ¥ç€æ‰‹è§£å†³é—®é¢˜ã€‚æˆ‘ä»¬çŸ¥é“æ•°æ®ç»“æ„ä¸­å¯ä»¥åˆ’åˆ†ä¸ºä¸‰å¤§ç±»ï¼šçº¿æ€§è¡¨ã€æ ‘ã€å›¾(æ ‘å’Œå›¾æœ‰æ—¶ä¹Ÿç»Ÿç§°ä¸ºéçº¿æ€§è¡¨)ã€‚ä¸€èˆ¬ï¼Œ**åœ¨çº¿æ€§è¡¨ä¸­ï¼Œå…ƒç´ ä¹‹é—´æ²¡ä»€ä¹ˆå…³ç³»**ã€‚åœ¨è¿™ä¸ªé¢˜ä¸­ï¼Œå¾ˆæ˜æ˜¾å•è¯ä¹‹é—´æ˜¯æœ‰å…³ç³»çš„(æœ€å¤šä¸€ä¸ªå•è¯å·®å¼‚)ã€‚é‚£ä¹ˆå…ƒç´ ä¹‹é—´æœ‰å…³ç³»çš„æ•°æ®ç»“æ„åªæœ‰æ ‘å’Œå›¾äº†ï¼Œ**ä½†æ ‘ä¹‹é—´çš„å…ƒç´ ä¸€èˆ¬æ˜¯å±‚æ¬¡å…³ç³»ï¼Œæ‰€ä»¥æ˜¾ç„¶ï¼Œè¿™ä¸ªé¢˜ç”¨å›¾æ¥è§£å†³**ã€‚

### 2. å¦‚ä½•å»ºå›¾ï¼Ÿ

æˆ‘ä»¬çŸ¥é“è¿™ä¸ªæ˜¯å›¾çš„é—®é¢˜ä¹‹åï¼Œé‚£ä¹ˆå¦‚ä½•å»ºå›¾å‘¢ï¼Ÿæ˜¯å»ºæœ‰å‘å›¾è¿˜æ˜¯æ— å‘å›¾å‘¢ï¼Ÿå¾ˆæ˜æ˜¾ï¼Œè¿™ä¸ªæ˜¯æ— å‘å›¾ã€‚å…¶å®ä¸ç®¡æ˜¯æ— å‘å›¾å’Œæœ‰å‘å›¾ï¼Œå»ºå›¾çš„æ–¹å¼å°±æ˜¯ä¸¤ç§ï¼šé‚»æ¥è¡¨å’Œé‚»æ¥çŸ©é˜µã€‚è¿™ä¸¤ä¸ªæ¦‚å¿µå¤§å®¶åº”è¯¥éƒ½çŸ¥é“ã€‚**åœ¨è¿™ä¸ªé¢˜é‡Œï¼Œé‚»æ¥è¡¨å’Œé‚»æ¥çŸ©é˜µéƒ½å¯ä»¥ï¼Œä¸ç”¨è€ƒè™‘å…ƒç´ æ˜¯å¦ç¨€ç–ã€‚æˆ‘ç”¨çš„æ˜¯é‚»æ¥è¡¨çš„æ–¹å¼**ã€‚å…ˆä¸Šä»£ç ã€‚

* 

```
public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {
        //ä½¿ç”¨hashmapæ˜¯ä¸ºäº†å»ºç«‹å•è¯åœ¨é‚»æ¥è¡¨ä¸­çš„ä¸‹æ ‡ï¼Œä»¥æ­¤æ¥è¡¨å¾æ¯ä¸ªå•è¯
        HashMap<String,Integer>word_index=new HashMap<>();
        for (int i = 0; i <wordList.size() ; i++) {
            word_index.put(wordList.get(i),i);
        }
        //è¿™é‡Œéœ€è¦æ³¨æ„çš„æ˜¯beginWordå¯èƒ½ä¸åœ¨wordListä¸­ï¼Œå¦‚æœä¸åœ¨éœ€è¦æ·»åŠ è¿›å»
        List<String>newWordList=new ArrayList<>(wordList);
        if(!word_index.containsKey(beginWord)){
            word_index.put(beginWord,wordList.size());
            newWordList.add(beginWord);
        }
        //æ„å»ºé‚»æ¥è¡¨å¹¶åˆå§‹åŒ–
        List<List<Integer>>graph=new LinkedList<>();
        for (int i = 0; i <newWordList.size() ; i++) {
            graph.add(new ArrayList<>());
        }
        //é‚»æ¥è¡¨å¡«å€¼
        for (int i = 0; i <newWordList.size() ; i++) {
            for (int j = 0; j < newWordList.size(); j++) {
                 if(i!=j&&onlyOneDiff(newWordList.get(i),newWordList.get(j))){
                     graph.get(i).add(j);
                 }
            }
        }

        ......

        private boolean onlyOneDiff(String word1,String word2){
        int count=0;
        for (int i = 0; i <word1.length() ; i++) {
            if(word1.charAt(i)!=word2.charAt(i)){
                count++;
            }
            if(count>=2){
                return false;
            }
        }
        return true;
    }
```

### 3. å¦‚ä½•è§£å†³æ— å‘å›¾é‡Œçš„æœ€çŸ­è·¯å¾„é—®é¢˜ï¼Ÿ

åœ¨å»ºå›¾äº†ä¹‹åï¼Œå¦‚ä½•æ‰¾åˆ°æœ€çŸ­è·¯å¾„é—®é¢˜ã€‚è¿™é‡Œåº”è¯¥è¦æ›´å…·ä½“ä¸€äº›ï¼Œå«**å•æºæœ€çŸ­è·¯å¾„é—®é¢˜**ã€‚å¯¹äºå•æºè·¯å¾„é—®é¢˜ï¼Œå¤§å®¶å°±ä¸ä¼šé™Œç”Ÿäº†å§ï¼Œç¬¬ä¸€å°è±¡æ˜¯ä¸æ˜¯æƒ³çš„å°±æ˜¯å›¾çš„Dijsktraç®—æ³•ã€‚**Dijsktraç®—æ³•ä¸€èˆ¬ç”¨äºæœ‰æƒå›¾ï¼Œç”¨åœ¨è¿™é‡Œå°±å¤§æå°ç”¨äº†**(è™½ç„¶ä¹Ÿå¯ä»¥å°†æ¯ä¸ªè¾¹çš„æƒé‡çœ‹ä¸º1)ï¼Œå¯¹äºæ— æƒå›¾(å³æ¯ä¸ªè¾¹çš„æƒé‡å¯ä»¥çœ‹ä¸º1)ï¼Œè¿™é‡Œæˆ‘ä»¬ç›´æ¥ä½¿ç”¨BFSå°±å¯ä»¥è§£å†³é—®é¢˜ã€‚å†™è¿‡BFSçš„åŒå­¦åº”è¯¥çŸ¥é“ï¼Œ**BFSç”¨æ¥æ‰¾æœ€çŸ­çš„è·¯å¾„é•¿åº¦å¾ˆå¥½å†™ï¼ŒæŒ‰ç…§æ¨¡æ¿å†™å°±å¥½ã€‚ä½†æ˜¯æ€ä¹ˆè®°å½•æœ€çŸ­è·¯å¾„å‘¢**ï¼Ÿè¿™é‡Œæˆ‘èµ·åˆä¹Ÿä¸çŸ¥é“ï¼Œç›´åˆ°çœ‹äº†é¢˜è§£åŒºé‡Œçš„ä¸€ç¯‡é¢˜è§£ï¼Œâ€œ**é€šè¿‡å¼•å…¥èŠ‚ç‚¹ç±»ï¼Œåœ¨è¿™ä¸ªèŠ‚ç‚¹é‡Œè®°å½•ä¸Šä¸€ä¸ªèŠ‚ç‚¹**â€ã€‚æˆ‘è§‰å¾—è¿™ä¸ªæ–¹å¼åˆç®€ä¾¿åˆå¥½ç”¨ï¼Œè¯ä¸å¤šè¯´ï¼Œä¸Šä»£ç ï¼š

* 

```
        //bfsæ‰¾åˆ°åˆ°è¾¾endWordçš„æ‰€æœ‰è·¯å¾„ï¼Œè¿™é‡Œä¸æ˜¯æœ€çŸ­è·¯å¾„å“¦
        Queue<Node>queue=new LinkedList<>();
        boolean visited[]=new boolean[newWordList.size()];
        int start=word_index.get(beginWord);
        queue.add(new Node(beginWord,start,null));
        while (!queue.isEmpty()){
            int size=queue.size();
            for (int i = 0; i <size ; i++) {
                Node cur=queue.poll();
                visited[cur.index]=true;
                if(cur.word.equals(endWord)){
                    ends.add(cur); //è®°å½•endWordæœ€ç»ˆèŠ‚ç‚¹,å¯èƒ½æœ‰å¤šä¸ªè·¯å¾„ï¼Œ
                }
                for(int ele:graph.get(cur.index)){
                    if(!visited[ele]&&onlyOneDiff(cur.word,newWordList.get(ele))){
                        queue.add(new Node(newWordList.get(ele),ele,cur));
                    }
                }
            }
        }
        //é€šè¿‡endWordèŠ‚ç‚¹åæ¨è·¯å¾„
        for(Node node:ends){
            List<String>tmp=new ArrayList<>();
            while (node.prev!=null){
                tmp.add(0,node.word);
                node=node.prev;
            }
            tmp.add(0,beginWord);
            
            paths.add(tmp);  
        }
        return paths;
    }
    private boolean onlyOneDiff(String word1,String word2){
        int count=0;
        for (int i = 0; i <word1.length() ; i++) {
            if(word1.charAt(i)!=word2.charAt(i)){
                count++;
            }
            if(count>=2){
                return false;
            }
        }
        return true;
    }

    class Node{
        String word;
        int index;
        Node prev;
        public Node(String word,int index,Node prev){
            this.prev=prev;
            this.index=index;
            this.word=word;
        }
    }
```

**è¿™é‡Œbfsçš„å†™æ³•ä¸ºä»€ä¹ˆä¸æ˜¯æœ€çŸ­è·¯å¾„å‘¢**ï¼Ÿå¦‚æœæœ‰åŒå­¦å¯¹BFSè§£å†³æœ€çŸ­è·¯å¾„é•¿åº¦çš„æ¨¡æ¿ä¸è®¤çœŸæ€è€ƒçš„è¯ï¼Œè¿™é‡Œå¯èƒ½å°±æ‰å‘é‡Œäº†ï¼Œä¸ºä»€ä¹ˆBFSå¯ä»¥è½»æ¾è§£å†³â€œæœ€çŸ­è·¯å¾„é•¿åº¦â€çš„é—®é¢˜ï¼Œå› ä¸ºBFSçš„æ ¸å¿ƒæ˜¯æŒ‰ç…§å±‚æ¬¡éå†ï¼ŒæŒ‰ç…§æ¯å±‚æ¯å±‚çš„å»éå†ï¼Œæœ€å…ˆè®¿é—®åˆ°ç›®æ ‡èŠ‚ç‚¹çš„é•¿åº¦è‚¯å®šæ˜¯æœ€çŸ­çš„ã€‚ä½†æ˜¯è¿™é‡Œçš„å†™æ³•ï¼Œå¹¶ä¸æ˜¯ç¬¬ä¸€æ¬¡æ‰¾åˆ°endWordæˆ‘å°±åœæ­¢éå†äº†ï¼Œæˆ‘è¿˜æ˜¯ç»§ç»­å¯»æ‰¾ã€‚**å› ä¸ºæœ€çŸ­è·¯å¾„ä¸åªä¸€ä¸ªï¼Œå¦‚æœåœæ­¢å¯»æ‰¾ï¼Œä¼šæ‰¾ä¸å…¨**ã€‚é‚£ä¹ˆå¦‚ä½•**æ‰¾åˆ°å…·æœ‰æœ€çŸ­è·¯å¾„é•¿åº¦çš„æœ€çŸ­è·¯å¾„å‘¢**ï¼Ÿè¿™ä¸å°±æ˜¯å¤šè§£å†³ä¸€ä¸ªæœ€çŸ­è·¯å¾„é•¿åº¦é—®é¢˜å—ï¼Ÿæ‰€ä»¥è¿™æ—¶ï¼Œä¼šä¸ä¼šæœ‰åŒå­¦è¯´è¿™ä¸ªé¢˜æˆ‘é—­ç€çœ¼ç›å°±ä¼šå†™ï¼Œä½†æ˜¯çœŸçš„å—ï¼Ÿ=.= è¿™é‡Œè¿˜æ˜¯æœ‰ä¸åŒçš„ï¼æˆ‘ä»¬ç†ŸçŸ¥çš„BFSè§£å†³æœ€çŸ­è·¯å¾„é•¿åº¦é—®é¢˜çš„å†™æ³•æ˜¯æ‰¾åˆ°æœ€çŸ­è·¯å¾„ä¾¿returnäº†ï¼Œä½†æ˜¯è¿™é‡Œä½ å¯ä»¥ç›´æ¥returnå—ï¼ŸğŸ¤”ï¸ï¼ŒåŠ¨åŠ¨è„‘ç“œå­ï¼Œæ˜¯ä¸æ˜¯ä¸å¯ä»¥ï¼Œæ‰€ä»¥å‘¢ï¼Œè¿™é‡Œè¦ç”¨ä¸¤ä¸ªå˜é‡ï¼Œå»è®°å½•æœ€çŸ­çš„è·¯å¾„é•¿åº¦ã€‚stepè®°å½•è®¿é—®åˆ°endWordçš„è·¯å¾„é•¿åº¦ï¼Œå› ä¸ºè¿™ä¸ªè·¯å¾„æœ‰å¤šä¸ªï¼Œæ‰€ä»¥æˆ‘ä»¬è¦ç”¨miniumStepå»è®°å½•æœ€çŸ­çš„é‚£ä¸ªè·¯å¾„é•¿åº¦ã€‚

* 

```
    List<List<String>>paths=new ArrayList<>();
    List<Node>ends=new ArrayList<>();
    //bfsæ‰¾åˆ°æœ€çŸ­è·¯å¾„åŠæœ€çŸ­è·¯å¾„çš„é•¿åº¦
    Queue<Node>queue=new LinkedList<>();
    boolean visited[]=new boolean[newWordList.size()];
    int start=word_index.get(beginWord);
    queue.add(new Node(beginWord,start,null));
    int miniumStep=Integer.MAX_VALUE;
    int step=1;
    while (!queue.isEmpty()){
        int size=queue.size();
        for (int i = 0; i <size ; i++) {
            Node cur=queue.poll();
            visited[cur.index]=true;
            if(cur.word.equals(endWord)){
                ends.add(cur);
                miniumStep=Math.min(step,miniumStep);
            }
            for(int ele:graph.get(cur.index)){
                if(!visited[ele]&&onlyOneDiff(cur.word,newWordList.get(ele))){
                    queue.add(new Node(newWordList.get(ele),ele,cur));
                }
            }
        }
        step++;
    }
    for(Node node:ends){
        List<String>tmp=new ArrayList<>();
        while (node.prev!=null){
            tmp.add(0,node.word);
            node=node.prev;
        }
        tmp.add(0,beginWord);
        if(tmp.size()==miniumStep){
            paths.add(tmp);
        }
    }
    return paths;
}
```

### æœ€åï¼Œæœ€ç»ˆçš„ä»£ç 

* java

```java
class Solution {
   public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {
        HashMap<String,Integer>word_index=new HashMap<>();
        for (int i = 0; i <wordList.size() ; i++) {
            word_index.put(wordList.get(i),i);
        }
        List<String>newWordList=new ArrayList<>(wordList);
        if(!word_index.containsKey(beginWord)){
            word_index.put(beginWord,wordList.size());
            newWordList.add(beginWord);
        }
        List<List<Integer>>graph=new LinkedList<>();
        for (int i = 0; i <newWordList.size() ; i++) {
            graph.add(new ArrayList<>());
        }
        for (int i = 0; i <newWordList.size() ; i++) {
            for (int j = 0; j < newWordList.size(); j++) {
                 if(i!=j&&onlyOneDiff(newWordList.get(i),newWordList.get(j))){
                     graph.get(i).add(j);
                 }
            }
        }
        List<List<String>>paths=new ArrayList<>();
        List<Node>ends=new ArrayList<>();
        //bfsæ‰¾åˆ°æœ€çŸ­è·¯å¾„åŠæœ€çŸ­è·¯å¾„çš„é•¿åº¦
        Queue<Node>queue=new LinkedList<>();
        boolean visited[]=new boolean[newWordList.size()];
        int start=word_index.get(beginWord);
        queue.add(new Node(beginWord,start,null));
        int miniumStep=Integer.MAX_VALUE;
        int step=1;
        while (!queue.isEmpty()){
            int size=queue.size();
            for (int i = 0; i <size ; i++) {
                Node cur=queue.poll();
                visited[cur.index]=true;
                if(cur.word.equals(endWord)){
                    ends.add(cur);
                    miniumStep=Math.min(step,miniumStep);
                }
                for(int ele:graph.get(cur.index)){
                    if(!visited[ele]&&onlyOneDiff(cur.word,newWordList.get(ele))){
                        queue.add(new Node(newWordList.get(ele),ele,cur));
                    }
                }
            }
            step++;
        }
        for(Node node:ends){
            List<String>tmp=new ArrayList<>();
            while (node.prev!=null){
                tmp.add(0,node.word);
                node=node.prev;
            }
            tmp.add(0,beginWord);
            if(tmp.size()==miniumStep){
                paths.add(tmp);
            }
        }
        return paths;
    }
    private boolean onlyOneDiff(String word1,String word2){
        int count=0;
        for (int i = 0; i <word1.length() ; i++) {
            if(word1.charAt(i)!=word2.charAt(i)){
                count++;
            }
            if(count>=2){
                return false;
            }
        }
        return true;
    }

    class Node{
        String word;
        int index;
        Node prev;
        public Node(String word,int index,Node prev){
            this.prev=prev;
            this.index=index;
            this.word=word;
        }
    }
}
```

