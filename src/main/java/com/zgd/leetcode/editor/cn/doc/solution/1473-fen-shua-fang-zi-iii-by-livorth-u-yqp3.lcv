### 题目理解

说实话困难题的题目意思都不是很好懂
**现在给出一排房子，需要给他们上漆**
1. 有两种房子，房子的颜色由`houses `数组给出
   - 第一种是**干净的房子**，你**必须要给他上漆**，什么颜色的都行
   - 第二种是**去年刷过的房子**，你**不允许给他再次刷漆**，他是什么颜色就只能是什么颜色
2. 颜色有多种，但是刷漆要花钱
   - 最离谱的是刷**不同房子刷不同颜色的花费还各不相同**
   - 这个是由`cost`数组给出
3. 相同颜色还能形成街道
   - 只要是**连续的相同颜色**，他就能**形成街道**
   - 而且还要**实现target个街道**，刷数量也框死了

**题目要求是在给定社区数量`target`中寻找花费最少的方案，没有则返回-1**

这里我令：
- 房子的编号为 [1, m]
- 颜色的编号为 [1, n]，如果房子没有涂上颜色，那么记为 0
- 分区的编号为 [1,target]

---

### 解题分析

**相关标签：动态规划，那么就是用动态规划**

**1. 为什么用动态规划呢？**
- 存在**三种不同的变量**：**房子编号，颜色编号，分区编号**
- 我们求的是花费的金额最少，这个是根据上面三种不同变量来的
  - **每个不同的变量相组合，都可以形成一个特定的解**
  - 那么就是用动态规划
- 又**由于是三个变量**，那么就是说明是**使用三维的动归数组**。即：`dp[][][]`
  - 其中**三个维度分别对应房子编号，颜色编号，分区编号**

**2. 初始化**
- **将整个dp数组全部置为INF**
- **当房子编号与分区编号同时为0的时候，初始化为0**
  - 第0个房子只能形成0号分区
  - 不管怎么刷漆，都是不要钱的

**3. 求转移方程**
按照下面三个条件进行分类
1. **房子是否已经有颜色**
2. **与当前状态的颜色是否相同**
3. **是否需要开辟新的分区**

- **当前房子已经上色**
  - **颜色不符**：「本来的颜色」已经固定，不能再刷，不允许状态转移，置为INF
  - **颜色相符**：与「本来的颜色」相同，允许被转移
    - **开辟新分区**：从「上一分区」「不同颜色」房子中找「花费最少」的情况
    - **不开辟分区**：从「上一分区」「相同颜色」的房子中寻找
    - **然后从两者情况中找花费最少的进行状态转移**
- **当前房子还未上色**
  - **颜色随便换，所以无所谓**
    - **开辟新分区**：从「上一分区」「不同颜色」房子中找「花费最少」的情况
    - **不开辟分区**：从「上一分区」「相同颜色」的房子中寻找
    - **然后从两者情况中找花费最少的进行状态转移，同时要加上刷新漆要用的金额**

**4. 获得结果**
也就是dp数组的最后部分
- **颜色随意**
- **房子编号为末尾**，即`m`
- **房子分区为末尾**，即`target`
- 要是**得到的最小值为INF**，说明没救了，返回-1吧

---

### 代码

* java

```java
class Solution {
    // INF最大值，/2 是为了防止越界
    int INF = Integer.MAX_VALUE / 2;
    public int minCost(int[] houses, int[][] cost, int m, int n, int target) {
        //三个维度分别对应房子编号，颜色编号，分区编号
        int[][][] dp = new int[m + 1][n + 1][target + 1];

        // 将每一个位置初始化
        for(int i = 0; i < m; i++) {
            for(int j = 1; j <= n; j++) {
                for(int k = 0; k <= target; k++) {
                    dp[i][j][k] = (i == 0 && k == 0) ? 0 : INF;
                }
            }
        }

        // 遍历每个房子
        for(int i = 1; i <= m; i++){
            // 获取房子对应颜色，其中-1表示未上色
            int color = houses[i - 1];

            // 遍历每种可能的颜色
            for(int j = 1; j <= n; j++){
                // 遍历每种分区，分区必然从1开始
                for (int k = 1; k <= i && k <= target; k++){

                    // 第 i 间房子已经上色
                    if (color != 0) {
                        //「本来的颜色」已经固定，不能再刷，不允许状态转移，置为INF
                        if (j != color) {
                            dp[i][j][k] = INF;
                        }
                        // 与「本来的颜色」相同，允许被转移
                        else {
                            // 1. 当前颜色为新分区，前后房子颜色不同
                            // 即，从「上一分区」「不同颜色」房子中找「花费最少」的情况
                            int tmp1 = INF;
                            for (int p = 1; p <= n; p++) {
                                if (p != j) {
                                    tmp1 = Math.min(tmp1, dp[i - 1][p][k - 1]);
                                }
                            }

                            // 2. 不形成新分区，前后房子颜色相同
                            // 即，「上一分区」「相同颜色」的房子
                            int tmp2 = dp[i - 1][j][k];


                            // 两者情况中找花费最少的进行状态转移
                            dp[i][j][k] = Math.min(tmp1, tmp2);   
                        }

                    // 第 i 间房子尚未上色
                    }
                    else {
                        // 1. 给当前颜色设立新分区，前后房子颜色不同
                        // 即，从「上一分区」中，「不同颜色」房子中找「花费最少」的情况
                        int tmp1 = INF;
                        for (int p = 1; p <= n; p++) {
                            if (p != j) {
                                tmp1 = Math.min(tmp1, dp[i - 1][p][k - 1]);
                            }
                        }
                        // 2. 不形成新分区，前后房子颜色相同
                        // 即，「上一分区」「相同颜色」的房子
                        int tmp2 = dp[i - 1][j][k];

                        // 两者情况中找花费最少的进行状态转移，同时要加上刷新漆要用的金额
                        dp[i][j][k] = Math.min(tmp1, tmp2) + cost[i - 1][j - 1];
                    }
                }
            }
        }


        // 从「考虑所有房间，并且形成分区数量为 target」的所有方案中找答案
        int ans = INF;
        for (int i = 1; i <= n; i++) {
            ans = Math.min(ans, dp[m][i][target]);
        }

        return ans == INF ? -1 : ans;
    }
}
```

![image.png](https://pic.leetcode-cn.com/1620098024-QTSZrQ-image.png)

### 致谢题解参考

[**1. 官方题解：粉刷房子 III**](https://leetcode-cn.com/problems/paint-house-iii/solution/fen-shua-fang-zi-iii-by-leetcode-solutio-powb/)
[**2. 宫水三叶老师的题解：三维动态规划，以及其「状态定义」由来**](https://leetcode-cn.com/problems/paint-house-iii/solution/gong-shui-san-xie-san-wei-dong-tai-gui-h-ud7m/)

---

友链：[我的csnd题解](https://blog.csdn.net/Alivorth/article/details/116399075)

都看到这来了，能给个小小的赞吗QAQ
