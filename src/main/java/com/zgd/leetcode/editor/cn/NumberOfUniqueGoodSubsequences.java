//给你一个二进制字符串 binary 。 binary 的一个 子序列 如果是 非空 的且没有 前导 0 （除非数字是 "0" 本身），那么它就是一个 好 的
//子序列。 
//
// 请你找到 binary 不同好子序列 的数目。 
//
// 
// 比方说，如果 binary = "001" ，那么所有 好 子序列为 ["0", "0", "1"] ，所以 不同 的好子序列为 "0" 和 "1" 。 
//注意，子序列 "00" ，"01" 和 "001" 不是好的，因为它们有前导 0 。 
// 
//
// 请你返回 binary 中 不同好子序列 的数目。由于答案可能很大，请将它对 10⁹ + 7 取余 后返回。 
//
// 一个 子序列 指的是从原数组中删除若干个（可以一个也不删除）元素后，不改变剩余元素顺序得到的序列。 
//
// 
//
// 示例 1： 
//
// 输入：binary = "001"
//输出：2
//解释：好的二进制子序列为 ["0", "0", "1"] 。
//不同的好子序列为 "0" 和 "1" 。
// 
//
// 示例 2： 
//
// 输入：binary = "11"
//输出：2
//解释：好的二进制子序列为 ["1", "1", "11"] 。
//不同的好子序列为 "1" 和 "11" 。 
//
// 示例 3： 
//
// 输入：binary = "101"  1 0 1 --> 01 11  10  +1 = 0  1  +  1  1  11 +  1  0  10
//输出：5
//解释：好的二进制子序列为 ["1", "0", "1", "10", "11", "101"] 。
//不同的好子序列为 "0" ，"1" ，"10" ，"11" 和 "101" 。
//

// "111
// 1,11,111
// "100"
// 1 0 10 100  == 10+100
// "101"
// 1 0 10 101 11

// "11"
// 1 11
// "110"
// 1,11,0,10,110
// "1101"
// 1 0 11 10 110  111 101 1101

// "111
// 1,11,111
// "1111"
// 1,11,111,"111",
// "1110"
// 1,11,111 "110"
// 提示： 
//
// 
// 1 <= binary.length <= 10⁵ 
// binary 只含有 '0' 和 '1' 。 
// 
//
// Related Topics 字符串 动态规划 👍 46 👎 0


  
package com.zgd.leetcode.editor.cn;

public class NumberOfUniqueGoodSubsequences{

  /**
  * 1987
  * 不同的好子序列数目
  * 
  * 
  *
  * 2022-10-31 16:46:47
  */  
  public static void main(String[] args) {
    Solution solution = new NumberOfUniqueGoodSubsequences().new Solution();
  }

    /**
     * 记公式:
     * i=0: ends0 += ends1; has0=1;
     * i=1: ends1 += ends0+1
     * res = ends0+ends1+has0;
     */
  //leetcode submit region begin(Prohibit modification and deletion)
class Solution {
      /**
       * 这个题,如果想不出这种逻辑关系,完全没办法下笔.
       * 一开始去纠结n和n-1之间的关系,想不出来. 后面看解析,是长度之间的关系.
       * 举例: n=11010
       * 我们从左到右看,想象这个数是一个个从后面拼出来的
       * 1.首先n=1, 结果是1 (下面中括号里是新增的)
       * 2.n=11, 结果是1, [11]
       * 3.n=110, 结果是1,11, [{0},10,110]
       * 4.n=1101,结果是1,11,0,10,110, [101,1101,{111}]   1,11,0,10,110,101,1101,111, 10,110,1010,11010,1110
       * 5.n=11010,结果是1,11,0,10,110,101,1101,111,[100,1100,1010,11010,1110]
       * 分别看这四步,我们用3个变量ends0,ends1,has0分别表示0结尾的数,1结尾的数,是否有0:
       * 1.没啥好说的  ends1 =  1
       * 2.加了个1, 多出来一个1+'1', ends1 = ends1 + 1 = 2
       * 3.加了个0, 1和11都在后面加了个0多出了10和110,同时多了个单独的0, ends0+=ends1=2,has0=1
       * 4.加了个1,针对刚刚加入的0结尾的10,110后加了1,同时将最大的1结尾的11也加了1变成111, ends1+=ends0+1=5
       * 5.加了个0,看不出明细的逻辑,但是加了总数是5, 即ends0+=5, 正好是ends1的数量
       * 综上可得,当新加的字符是1时, ends1+=ends0+1, 这个1是因为1结尾最大那个还能加1不重复.
       *        当新加的字符是0时, has0=1, 且ends0+=ends1
       */
    public int numberOfUniqueGoodSubsequences(String binary) {
        long ends0=0,ends1=0,has0=0;
        for (int i = 0; i < binary.length(); i++) {
            if (binary.charAt(i) == '1'){
                ends1=(ends1+ends0+1)%(1_000_000_000+7);
            }else{
                has0=1;
                ends0=(ends0+ends1)%(1_000_000_000+7);
            }
        }
        return (int) (has0+ends1+ends0)% (1_000_000_000+7);
    }
}
//leetcode submit region end(Prohibit modification and deletion)

}