直接拿一个数字`31261`分析下，过程如下

* 

```
3      1      2      6      1
                            3126 + 1
                     3130
              3200
        3000 + 261 + 1
10000
```

1. 最低位当前数字是`1`，这个位置上`1`粗线的次数由他前面的数字决定，所以我们可以非常明白的知道，这个时候这一位一共出现了3127次字符`1`，
   - 分别为有前缀的3126 次
   - 和无前缀的  当数字`n = 1`的时候的1次
2. 倒数第二位数字`6`，这个数字大于`1`，根据上面算最低位的时候的情况分析依据，我们可以知道这个位置一共出现了3130次，这个结果可以也可以分为两部分
   - 有前缀的时候3120种情况，数字`xxx1x`的情况，当前位前面有312种情况，而又因为当前位大于1，后面一位的`0`-`9`的10种情况，即为3120种
   - 无前缀的时候`10`到`19`的10种情况
   - 这样，我们暂时把这部分换为另外一种算法，即为`( 312 + 1 ) * 10` 种。
3. 再往前一位数字`2`,同前面的数字`6`的情况，因为大于1所以结果为`(31 + 1) * 100`种
4. 再次往前一位，数字`1`，虽然前面为`1`的情况我们已经分析过了，但是那个是不完整的，在这里，我们将完整分析下为`1`的时候的情况
   - 因为后面还有其他数字，整个`31xxx`区段是还没完全结束的，所以我们不能直接得到结果为4000
   - 那么前面部分的情况为`0`，`1`，`2`的3000种情况，也可以认为如果左侧数字是`k`，那么现在就有`k000`次
   - 又因为之前说了这个`31xxx`区段是还没完全结束，所以应当还有当前位后面部分的`261`种情况，外加如果后面都为`0`的情况
   - 那么这个位置数字1出现的次数就是3000 + 261 + 1 = 3262
5. 最高位为3，大于1，可以直白的知道有10000次出现了字符1，那么按照前面的规律，我们假定最高位为0，按照之前的方法可以得到`( 0 + 1 ) * 10000`
6. 举例数据中没有出现的当前位为0的情况，这个就比较简单了，直接就是左侧数据出现的次数了
   - 如 30261 中0的位置，
   - 就是数字`1xxx`,`11xxx`,`21xxx`的3000种情况

# 计算中间的问题

我们在计算中使用了一个辅助变量`10`,`100`,`1000`，`10000`，这个数值是比入参数字大一位的

又因为题目给的入参条件` 1 <= n < 2^31 `

所以中间计算过程我就偷了个懒给转成了`long`型数据

另外，葱低往高取每一位的数字的时候可以直接用余10，之后再除10的方法，我这边一开始是准备转成数组直接根据数组计算左右侧数据影响的当前位置`1`出现次数的，最后就还是没改了

# 代码

* java

```java
class Solution {
    /*
    3      1      2      6      1
                                3127
                         3130
                  3200
            3000 + 261 + 1
     10000
     */


    final static int [] sizeTable = { 9, 99, 999, 9999, 99999, 999999, 9999999,
            99999999, 999999999, Integer.MAX_VALUE };

    public int countDigitOne(int n) {
        long ans = 0;
        long num = (long) n;
        int size = numSize(n);
        int[] arr = new int[size];
        int idx = size-1;
        while (n != 0){
            arr[idx] = n%10;
            n /= 10;
            idx--;
        }
        idx = size-1;
        long tmp = 10;
        while (idx >= 0){
            long r = 0;
            if (arr[idx] == 0){
                r = ( num / tmp ) * ( tmp / 10 );
            }
            if (arr[idx] == 1){
                r = ( num / tmp ) * ( tmp / 10 ) + ( num % (tmp / 10) ) + 1;
            }
            if (arr[idx] > 1){
                r = ( (num / tmp)+1 ) * ( tmp / 10 );
            }
            ans += r;
            tmp *= 10;
            idx--;
        }

        return (int)ans;
    }



    static int numSize(int x) {
        for (int i=0; ; i++)
            if (x <= sizeTable[i])
                return i+1;
    }
}
```

